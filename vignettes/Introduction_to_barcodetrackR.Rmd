---
title: "barcodetrackR"
date: (`r format(Sys.Date(), "%d %B %Y")`)
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    lightbox: false
    css: readthedown_custom_2.css
  github_document: default
---


``` {r setup, echo = FALSE}
#knitr::opts_chunk$set(width = 100)
```

# Introduction

## Motivation
[barcodetrackR](http://github.com/d93espinoza/barcodetrackR) is an R package developed for the analysis and visualization of clonal tracking data from cellular barcoding experiments.

## Installation
Currently, [barcodetrackR](http://github.com/d93espinoza/barcodetrackR) is available at Github and can be downloaded using the devtools package.
```{r installation, eval = FALSE}
devtools::install_github("d93espinoza/barcodetrackR")
```

## Contributors
The R package and functions were created by Diego A. Espinoza, Ryland Mortlock, Samson J. Koelle, and others at Cynthia Dunbar's laboratory at the National Heart, Lung, and Blood Institutes of Health. Issues should be addressed to https://github.com/d93espinoza/barcodetrackR/issues.


# Loading data

## Loading required packages

The [barcodetrackR](http://github.com/d93espinoza/barcodetrackR) package operates on [SummarizedExperiment](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) objects from the Bioconductor repository. It stores associated colData for each sample in this object as well as any metadata. We load the `barcodetrackR` and `SummarizedExperiment` packages here for our analyses, as well as the `magrittr` package in order to improve legibility of code through using the pipe `%>%` operator.

```{r load packages required, eval = TRUE, warning=FALSE, message=FALSE}

require("magrittr")
require("barcodetrackR")
require("SummarizedExperiment")

```

## Creating objects with `create_SE`

For this vignette, we will load publically available data from the following papers (these sample datasets are included in the R package):

* [Wu, Chuanfeng, et al. "Clonal expansion and compartmentalized maintenance of rhesus macaque NK cell subsets." Science Immunology (2018)](http://dx.doi.org/10.1126/sciimmunol.aat9781)
* [Koelle, Samson J., et al. "Quantitative stability of hematopoietic stem and progenitor cell clonal output in rhesus macaques receiving transplants." Blood (2017)](https://doi.org/10.1182/blood-2016-07-728691)
* [Belderbos, Mirjam E., et al. "Donor-to-Donor Heterogeneity in the Clonal Dynamics of Transplanted Human Cord Blood Stem Cells in Murine Xenografts." Biology of Blood and Marrow Transplantation (2020)](http://dx.doi.org/10.1016/j.bbmt.2019.08.026)
* [Six, Emmanuelle, et al. "Clonal tracking in gene therapy patients reveals a diversity of human hematopoietic differentiation programs." Blood (2020)](http://doi.org/10.1182/blood.2019002350)

```{r load data, eval = TRUE}

system.file("sample_data/WuC_etal/monkey_ZJ31.txt", package = "barcodetrackR") %>%
  read.delim(row.names = 1) -> wu_dataframe

system.file("sample_data/WuC_etal/monkey_ZJ31_metadata.txt", package = "barcodetrackR") %>%
  read.delim() -> wu_metadata

wu_SE <- create_SE(your_data = wu_dataframe,
                   meta_data = wu_metadata,
                   threshold = 0)

system.file("sample_data/KoelleSJ_etal/ZH33_reads.txt", package = "barcodetrackR") %>%
  read.delim(row.names = 1) -> koelle_dataframe

system.file("sample_data/KoelleSJ_etal/ZH33_metadata.txt", package = "barcodetrackR") %>%
  read.delim() -> koelle_metadata

koelle_SE <- create_SE(your_data = koelle_dataframe,
                       meta_data = koelle_metadata,
                       threshold = 0)

system.file("sample_data/BelderbosME_etal/mouse_UBC_C22.txt", package = "barcodetrackR") %>%
  read.delim(row.names = 1) -> belderbos_dataframe

system.file("sample_data/BelderbosME_etal/mouse_UBC_C22_metadata.txt", package = "barcodetrackR") %>%
  read.delim() -> belderbos_metadata

belderbos_SE <- create_SE(your_data = belderbos_dataframe,
                          meta_data = belderbos_metadata,
                          threshold = 0)


system.file("sample_data/SixE_etal/WAS5_reads.txt", package = "barcodetrackR") %>%
  read.delim(row.names = 1) -> six_dataframe

system.file("sample_data/SixE_etal/WAS5_metadata.txt", package = "barcodetrackR") %>%
  read.delim() -> six_metadata

six_SE <- create_SE(your_data = six_dataframe,
                    meta_data = six_metadata,
                    threshold = 0)

```

In addition to reads data, the Six et al. paper includes "estimated abundance" data for each of these timepoints. We load these into a new SE in order to compare our analyses downstream.

```{r load custom counts, eval = TRUE}

system.file("sample_data/SixE_etal/WAS5_estabundance.txt", package = "barcodetrackR") %>%
  read.delim( row.names = 1) -> six_dataframe_2

six_ea_SE <- create_SE(your_data = six_dataframe_2,
                    meta_data = six_metadata,
                    threshold = 0)

```

Our input dataframes to create the `SummarizedExperiment` (SE) objects are each an n x m `data.frame` where there are n rows of observations (typically cellular barcodes, insertion sites, or the like) and the m columns are the samples. The input metadata must have row order identical to the order of the colums in its corresponding dataframe. The metadata must also have a column titled `SAMPLENAME` that denotes the column of `your_data` it refers to.

## Assays created by `create_SE`

`create_SE` takes the input `dataframe` and metadata and creates a SummarizedExperiment object with the following assays:

* `counts`: the raw values from the input dataframe
* `percentages`: the per-column proportions of each entry in each column
* `ranks`: the rank of each entry in each column
* `normalized`: the normalized read values (CPM)
* `logs`: the log of the normalized values

```{r list assays, eval = TRUE}
assays(six_SE)
```

# Correlations

## `scatter_plot`
A straightforward way to view the relationship between samples in a pairwise manner is to view basic scatter plots of two samples using the provided assays. We provide a `scatter_plot` function as part of the package.

Here, we view the correlation of barcode counts between different cell types at the 20 month timepoint of the Wu et al study. We compare granulocytes (Gr) to B and T cells.

```{r scatter_plot, eval = TRUE, fig.width = 7, fig.height=4}
Gr_B_20 <- c("ZJ31_20m_Gr", "ZJ31_20m_B")
Gr_T_20 <- c("ZJ31_20m_Gr", "ZJ31_20m_T")
wu_scatterplot_1 <- scatter_plot(wu_SE[,Gr_B_20], your_title = "Gr vs B")
wu_scatterplot_2 <- scatter_plot(wu_SE[,Gr_T_20], your_title = "Gr vs T")
cowplot::plot_grid(wu_scatterplot_1, wu_scatterplot_2, ncol = 2)
```

## `cor_plot`
A more comprehensive way to view the relationship between samples in a pairwise manner is to use a correlation plot. Here, we view the Pearson correlation between the T, B, Gr, NK CD56+/CD16-, and NK CD56-/CD16+ fractions within the Wu dataset for the 6, 9.5, 12, and 20 month post-transplant timepoints.
```{r cor_plot 1, eval = TRUE, fig.width = 6, fig.height = 5}
wu_cor_plot_sample_selection <- colData(wu_SE)$SAMPLENAME[1:20]
cor_plot(wu_SE[,wu_cor_plot_sample_selection],
         method_corr = "pearson",
         plot_type = "color")
```

A number of options are included; here we plot the Koelle dataset for all included samples and observe the high pairwise correlation of Monocyte and Granulocyte samples.
```{r cor_plot 2, eval = TRUE, fig.width = 6, fig.height = 5, warning=FALSE, message=FALSE}
cor_plot(six_SE[,16:20],
         method_corr = "pearson",
         plot_type = "circle",
         label_size = 12,
         point_scale = 20)
```

We can return a table of the Pearson correlations as well as the p-values and confidence intervals for each of the comparisons above.
```{r cor_plot 3, eval = TRUE}
cor_plot(wu_SE[,wu_cor_plot_sample_selection],
         method_corr = "pearson",
         return_table = TRUE) %>% head
```

Above, we used two of the three available correlation visualizations (`"color"` and `"circle"`) using the standard color palette provided. A `no_negative` parameter is offered as well to eliminate negative correlations within the data, from which deriving biological meaning may be difficult.

When there are a smaller number of samples to analyze, the `"number"` option can be used to view the actual correlation within the grid. Here is an example comparing the pearson correlation of clones within peripheral blood at subsequent timepoints from the belberdos sample data set.

```{r cor_plot 4, eval = TRUE, fig.width = 4, fig.height = 3, warning=FALSE, message=FALSE}
belderbos_wk_samples_PB <- c("wk10", "wk14", "wk20", "wk27", "wk33")
cor_plot(your_SE = belderbos_SE[,belderbos_wk_samples_PB],
         method_corr = "pearson",
         plot_type = "number",
         number_size = 3)
```

# Clonal patterns

## `barcode_ggheatmap`

A useful visualization to study clonal patterns over time is by using a heat map which clusters the top clones based on relatedness and displays their proportion in each sample over time. Our function `barcode_ggheatmap` does this by choosing the top N clones (`n_clones`) within each sample and tracking them over time. The argument `n_clones` assumes that in most cases, the large-contributing clones are of most interest to the user. This assumption can be relaxed by passing a large value to the argument.

We first visualize the top 10 clones from the selected samples in the Wu dataset. The default cell note is stars for the top 10 clones in each sample.

```{r barcode_ggheatmap wu_SE 1, echo=TRUE, warning = FALSE, fig.width = 12, fig.height=10}
barcode_ggheatmap(your_SE = wu_SE[,wu_cor_plot_sample_selection],
                  n_clones = 10,
                  label_size = 14,
                  cellnote_size = 4)
```

We can also add a dendogram which clusters clones based on the Euclidean distance between each clone's log assay. Here we plot the top 5 clones within the Six dataset. First, we order the columns to group them by celltype. The dendrograms make it easily to visually categorize groups of similar clones.

```{r barcode_ggheatmap six_SE, echo=TRUE, warning = FALSE, fig.width = 12, fig.height=10}
six_celltype_order <- c("m13_TCELLS", "m36_TCELLS", "m43_TCELLS", "m55_TCELLS",
                        "m13_BCELLS", "m36_BCELLS", "m43_BCELLS", "m55_BCELLS",
                        "m13_NKCELLS", "m36_NKCELLS", "m43_NKCELLS","m55_NKCELLS",
                        "m13_GRANULOCYTES", "m36_GRANULOCYTES", "m43_GRANULOCYTES",
                        "m55_GRANULOCYTES",
                        "m13_MONOCYTES", "m36_MONOCYTES", "m43_MONOCYTES","m55_MONOCYTES")

barcode_ggheatmap(your_SE = six_SE[,six_celltype_order],
                  n_clones = 5,
                  cellnote_assay = "stars",
                  cellnote_size = 6,
                  label_size = 14,
                  dendro = TRUE,
                  clusters = 4,
                  distance_method = "euclidean")
```

The Belderbos dataset generally contains less clones than either the Wu or Six datasets, likely because the data is from mice.  When possible, using the "percentages" option of the `cellnote_assay` argument provides maximal information.

```{r barcode_ggheatmap belderbos_SE, echo=TRUE, warning = FALSE, fig.width = 7, fig.height = 5}
belderbos_wk_samples_PB <- c("wk10", "wk14", "wk20", "wk27", "wk33")
barcode_ggheatmap(your_SE = belderbos_SE[,belderbos_wk_samples_PB],
                  n_clones = 10,
                  label_size = 18,
                  dendro = TRUE,
                  cellnote_size = 4,
                  cellnote_assay = "percentages",
                  clusters = 4)
```

## `barcode_ggheatmap_stat`

In some cases, we may be interested in whether each barcode changed in proportion from one sample to another. The function barcode_ggheatmap_stat allows users to layer information from statistical tests onto the heat map. Note that this test requires an additional piece of information, which is the sample size of cells which the barcoding data approximates. In this case, we view the CD16+ NK cells from the Wu dataset at various timepoints, using a sample size of 5,000 barcoded cells per sample.

The stars in the heat map indicate which barcodes in a given sample had a statistically signficant change in proportion, as compared to the previous sample using a chi-squared test. Users can view the p-value from the statistical test on the hatmap by changing the `cellnote_assay` parameter to `"p_val"`. Users can also compare each sample to a reference sample (such as the first timepoint) by changing the `stat_option` to `"reference"` and providing the desired sample name to the `reference_sample` parameter.

```{r barcode_ggheatmap_stat wu_SE, echo=TRUE, warning = FALSE, fig.width = 10, fig.height=7}
wu_CD16_NK_order <- c("ZJ31_3m_NK_CD56n_CD16p", "ZJ31_4m_NK_CD56n_CD16p",
                      "ZJ31_6m_NK_CD56n_CD16p", "ZJ31_8.5m_NK_CD56n_CD16p",
                      "ZJ31_9.5m_NK_CD56n_CD16p", "ZJ31_12m_NK_CD56n_CD16p",
                      "ZJ31_17.5m_NK_CD56n_CD16p", "ZJ31_20m_NK_CD56n_CD16p")

barcode_ggheatmap_stat(your_SE = wu_SE[,wu_CD16_NK_order],
                       sample_size = rep(5000,length(wu_CD16_NK_order)),
                       stat_test = "chi-squared",
                       stat_option = "subsequent",
                       p_threshold = 0.05,
                       n_clones = 10,
                       cellnote_assay = "stars",
                       cellnote_size = 6)
```

Users can also return the results from the statistical test using the `barcode_statistics` function which outputs a list containing the FC, log_FC, and p-value of each barcode for each sample. The inputs are similar to the `barcode_ggheatmap_stat function`. The function only performs statistical testing on the barcodes which have a proportion greater than `bc_threshold` in at least one sample. It is important to set this parameter to avoid long computation times. 

Here we make statistical comparisons on the CD16+ NK samples form the Wu dataset. 

```{r barcode_statistics wu_SE, eval = TRUE, echo=TRUE, warning = FALSE}

wu_CD16_NK_statistics <- barcode_statistics(your_SE = wu_SE[,wu_CD16_NK_order],
                                            sample_size = rep(5000,length(wu_CD16_NK_order)),
                                            stat_test = "chi-squared",
                                            stat_option = "subsequent",
                                            bc_threshold = 0.001)

head(wu_CD16_NK_statistics$p_val[,4:5])
```


## `barcode_binary_heatmap`

In some cases, we may be interested in a global view of the presence or absence of barcodes across samples, regardless of read abundance. In that case, a binary heat map can be generated using `barcode_binary_heatmap` to give the simplest visual representation. Here we view the binary heat map of the belderbos data with a threshold of 0.01, meaning clones that make up less than 1% of a sample are treated as not detected.

```{r binary_heat_map, echo=TRUE, warning = FALSE, eval = TRUE}
barcode_binary_heatmap(your_SE = belderbos_SE[,belderbos_wk_samples_PB],
                       label_size = 12,
                       threshold = 0.01)
```

## `clonal_contribution`

Another familiar way to visualize clonal patterns over time is using a line or bar chart showing the proportion of top clones. In the above heat maps for wu data, we could see that there are some large uni-lineage CD56-/CD16+ NK cell clones. We can view the expansion of the top clones from the final timepoint through a stacked area line chart showing the proportion of each clone in CD56-/CD16+ NK cell samples across time. Each color indicates one of the top clones from the final timepoint.

```{r clonal_contribution wu_SE, echo=TRUE, warning = FALSE}

clonal_contribution(your_SE = wu_SE,
                    SAMPLENAME_choice = "ZJ31_20m_NK_CD56n_CD16p",
                    n_clones = 10,
                    graph_type = "line",
                    plot_over = "months",
                    filter_by = "celltype",
                    filter_selection = "NK_CD56n_CD16p",
                    plot_non_selected = FALSE)
```

For data with fewer clones, a bar chart might be appropriate. We can view the peripheral blood samples from the belderbos dataset, previously shown as a heat map. By turning the `plot_non_selected` argument to True, we can see all clones as stacks on the bar but only color the top 10 clones from the chosen sample. We can also use categorical spacing on the x-axis rather than numeric by setting `keep_numeric` to false.

```{r clonal_contribution belderbos_SE, echo=TRUE, warning = FALSE, eval = TRUE}
clonal_contribution(your_SE = belderbos_SE,
                    SAMPLENAME_choice = "sac",
                    n_clones = 10,
                    graph_type = "bar",
                    plot_over = "weeks",
                    filter_by = "source",
                    filter_selection = "PB",
                    keep_numeric = FALSE,
                    plot_non_selected = TRUE)
```

# Clonal bias

## `bias_histogram`
The most straightforward way to view the bias between samples is using a histogram. We include the bias_histogram function which allows users to compare two samples from a given piece of metadata `"split_bias_on"` faceted by another piece of metadata `"split_bias_over"`, which is illustrated below using the Wu et al data comparing clonal bias between B and T cells from the 6, 9.5, 12, and 20 month post-transplant timepoints.

```{r bias_histogram wu_SE, echo=TRUE, warning = FALSE, eval = TRUE}

wu_bias_plot_sample_selection <- colData(wu_SE)$SAMPLENAME[1:20]

bias_histogram(your_SE = wu_SE[,wu_bias_plot_sample_selection],
               split_bias_on = "celltype",
               bias_1 = "B",
               bias_2 = "Gr",
               split_bias_over = "months",
               ncols = 2)

```

The stacked bars of the histogram represent individual clones. For the Wu dataset, there are a multitude of small clones so the stacked bars are not visible. We can view clonal bias between B and T cells from the Six, et al dataset which has a smaller number of larger clones.

```{r bias_histogram six_SE, echo=TRUE, warning = FALSE, eval = TRUE}
bias_histogram(your_SE = six_SE,
               split_bias_on = "celltype",
               bias_1 = "B",
               bias_2 = "T",
               split_bias_over = "months",
               ncols = 2)
```

## `ridge_plot`
An alternative to the histogram is a ridge plot which shows clonal bias between cell types through a density estimation of the number of clones at each value of the log bias. Since the ridge plot treats clonal bias as a continuous variable, it can reveal trends that are masked by grouping into bins with a histogram. 

It is important to note that in order to handle clones which have a count of zero in one of the samples, log+1 normalization is used within the ridge plot function. This differs from the histogram where these clones can be grouped into the farthest bins on either side. The log bias formula for the ridge plot function is given by:

$logbias=log(\frac{normalized_1+1}{normalized_2+1})$

Here, we view a ridge plot showing clonal bias between B cells and Granulocytes from the Wu dataset. We calculate the density statistic using the cumulative sum of the normalized values for each log2 comparison. We also visualize each clone as a dot on the plot, proportionate to the cumulative sum of the normalized values.

```{r ridge_plot wu_SE 1, echo=TRUE, warning = FALSE, eval = TRUE}
ridge_plot(your_SE = wu_SE,
           split_bias_on = "celltype",
           bias_1 = "B",
           bias_2 = "Gr",
           split_bias_over = "months",
           weighted = TRUE,
           add_dots = TRUE)
```

We again view a comparison in the Wu dataset, this time comparing B cells to Granulocytes but turning the weighting OFF.

```{r ridge_plot wu_SE 2, echo=TRUE, warning = FALSE, eval = TRUE}
ridge_plot(your_SE = wu_SE,
           split_bias_on = "celltype",
           bias_1 = "B",
           bias_2 = "Gr",
           split_bias_over = "months",
           weighted = FALSE,
           add_dots = TRUE)
```

## `bias_lineplot`
In some cases, there may be enough data to observe more interesting longitudinal trends. In the Koelle dataset, we can track the Monocyte vs Granulocyte abundance bias of all individual clones over time; the clones that have higher expression are evident on the plot and suggest that the highest abundance clones in both lineages seem to have similar abundances in each lineage over time.

```{r bias_lineplot koelle_SE, echo=TRUE, warning = FALSE, eval = TRUE}
bias_lineplot(your_SE = koelle_SE,
              split_bias_on = "celltype",
              bias_1 = "Gr",
              bias_2 = "Mono",
              split_bias_over = "months")
```


# Diversity

## `rank_abundance`
A way to depict clone richness and evenness within a plot is by using a rank-abundance plot. Here, the cumulative abundance of every clone in a sample is plotted in descending rank from 1 to n (where there are n clones in the sample being plotted), or by scaling all ranks to the range [0,1].

We plot all samples from the Belderbos dataset. Note that the week 10 and 14 samples appear to have the most _evenness_ across detected clones, while the other samples contain both large and small detected clones.
```{r belderbos rank_abundance, eval = TRUE}
rank_abundance_plot(belderbos_SE, scale_rank = TRUE)
```

## `clonal_diversity`
Within-sample diversity indices (also referred to as alpha diversities) are indices computed independently for each sample in a data set. With clonal tracking, these diversity indices can give a global indication about the number of species in a sample using the number of detected species as input and sometimes also leveraging the proportional abundances of species within the sample. We include the function `clonal_diversity` which can calculate three diversity indices (making use the [`vegan`](https://cran.r-project.org/web/packages/vegan/) package):

* `"shannon"` $H'=-\sum _{i=1}^{R}p_{i}\ln p_{i}$
* `"simpson"` $\lambda =\sum _{i=1}^{R}p_{i}^{2}$
* `"invsimpson"`${\displaystyle {\frac {1}{\lambda }}={1 \over \sum _{i=1}^{R}p_{i}^{2}}={}^{2}D}$

We also include `"count"` as an option for `index_type` in order to use the total detected clones per sample as a measure for diversity.

As an example, we can plot the shannon diversities for the 5 cell types within the Wu dataset over time.
```{r wu shannon, eval = TRUE}
clonal_diversity(wu_SE[,1:20], plot_over = "months", group_by = "celltype", index_type = "shannon")
```

Here we show the simpson indices for the unsorted samples in the Belderbos dataset over time; the last time point splits the cell fraction in to T, B, and Granulocyte fractions, allowing comparison of their shannon indices.

```{r belderbos shannon, eval = TRUE}
clonal_diversity(belderbos_SE, plot_over = "weeks", group_by = "cell.type", index_type = "shannon")
```

Similar to the Wu dataset, the Six dataset contains clonal tracking information for the T, B, Gr, Monocyte, and NK lineages. We can plot these over time as well and utilize the simpson index as a measure of diversity. 

```{r six simpson, eval = TRUE}
clonal_diversity(six_SE, plot_over = "months", group_by = "celltype", index_type = "simpson")
```

## `mds_plot`
Measures of simmilarity or dissimilarity between samples are known as beta-diversity indices (or distances if they are metrics). A common way for depicting these beta-diversity indices are using what are known as PCoA (Principal Coordinate Analysis) plots, in which an input distance matrix is plotted in two dimensions. Again, we leverage the `"vegan"` package here to call `vegandist` which allows us to calculate a number of dissimilarity indices between our samples (choosing an assay from the `SummarizedExperiment` object) and then perform principal coordinates analysis using `cmdscale`. Note that using `"euclidean"` as our index is equivalent to performing PCA (Prinicipal Components Analysis) on our data.

One of the most commonly used beta-diversity indices is the [Bray-Curtis Dissimilarity](https://en.wikipedia.org/wiki/Bray%E2%80%93Curtis_dissimilarity). Here, we find the Bray-Curtis dissimilarity index between all of the samples in the Wu dataset and use PCoA to plot them on two dimensions. From the plot, it is evident that NK cells are most dissimilar from all other celltypes when considering the Bray-Curtis index.
```{r wu bray diversity, eval = TRUE}
mds_plot(wu_SE, label_by = "celltype", method_dist = "bray", assay = "percentages")
```

When using the Bray-Curtis dissimilarity index between all of the samples in the Six dataset, we find that similarly to the Wu dataset, NK cells appear dissimilar from the remainder of the celltypes, while Monocytes and Granulocytes appear most similar to one another.
```{r six bray diversity, eval = TRUE}
mds_plot(six_SE, label_by = "celltype", method_dist = "bray", assay = "percentages")
```


# Circos plot

The circos plot is a fun way to view relationships between variables. We make use of the [circlize package](https://jokergoo.github.io/circlize_book/book/graphics.html) to show shared clones between compartments as links between regions around a circle. Here, we will start by subetting our data to a single timepoint and comparing just three cell types: T cells, B cells, and Granulocytes. 

```{r circos_plot wu_SE 1, echo=TRUE, warning = FALSE, eval = TRUE}
wu_circos_selection <- c("ZJ31_12m_T","ZJ31_12m_B","ZJ31_12m_Gr")
circos_plot(wu_SE[,wu_circos_selection], plot_label = "celltype")
```

Here, we can see that most clones are present in all three cell types (*purple link*). There are also clones shared between each pair-wise combination of cell types. Based on the width of the links, you can ascertain that more clones are shared between Granulocytes and B cells (*yellow link*), followed by B cells and T cells (*blue link*), then T cells and Granulocytes (*green link*). The portion of each cell type without a link (*empty space*) represents the number of clones which are unique to that cell type.

We can also create a weighted circos plot. The difference is that in the previous plot, the width of the links between cell types are proportional to the *number of clones* shared between those cell types. In the weighted heat map, the width of the links between two cell types is proportional to the *proportion of contribution* of the shared clones to the overall hematopoiesis in that cell type.

```{r circos_plot wu_SE 2, echo=TRUE, warning = FALSE, eval = TRUE}
circos_plot(wu_SE[,wu_circos_selection], plot_label = "celltype", weighted = TRUE)
```

In this example, the circos plots look very similar. But you can see the subtle difference when you look at the blue link showing clones shared between B and T cells. The link is wider when connecting to T cells because the shared Bcell-Tcell clones represent a larger fraction of detected hematopoiesis in the T cell compartment than the B cell compartment. 

The circos plot can handle any number of inputs but keep in mind that the number of unique combinations rises exponentially with the number of compartments. Here, we use the alpha parameter to control the transparency of the links. And we plot four cell types rather than three.

```{r circos_plot wu_SE 3, echo=TRUE, warning = FALSE, eval = TRUE}
wu_circos_selection2 <- c("ZJ31_12m_T","ZJ31_12m_B","ZJ31_12m_Gr","ZJ31_12m_NK_CD56n_CD16p")
circos_plot(wu_SE[,wu_circos_selection2], plot_label = "celltype", alpha = 0.9)
```

The plot is quite involved, but we can quickly draw a few high-level conclusions. A large chunk of clones are shared between all four cell types (*darkest purple color*). Another large chunk of clones is shared between B cells, T cells, and Grans but not NK cells (*lighter purple*). Note that each unique color signifies a unique combination of the four cell types. 

The regions of the circos plot need not be cell types. They could also be timepoints. Here, we show that example using the belderbos dataset from mouse studies showing only the first four timepoints of peripheral blood samples.

```{r circos_plot belderbos_SE 1, echo=TRUE, warning = FALSE, eval = TRUE}
belderbos_wk_samples_PB <- c("wk10", "wk14", "wk20", "wk27", "wk33")
circos_plot(belderbos_SE[,belderbos_wk_samples_PB])
```

From the circos plot, we can see that the wk10 and wk14 timepoints have fewer number of clones detected, as indicated by their smaller bars around the perimeter. There are some clones shared between all timepoints (*dark purple links*) but most of the clones appear to be present in the wk20, wk27, and wk33 samples but not the wk10 and wk14 (*green and yellow links*).

```{r circos_plot belderbos_SE 2, echo=TRUE, warning = FALSE, eval=TRUE}
circos_plot(belderbos_SE[,belderbos_wk_samples_PB], weighted = TRUE)
```

When looking at the weighted heat map, one sees that the majority of hematopoiesis in timepoints past 10 weeks is accounted for by the group of clones (*turquoise color*) that are present at all timepoints except for the wk10 timepoint. There are some clones present at all timepoints (*dark purple*) and the green and yellow links mostly represent fraction of hematopoiesis in the later timepoints coming from clones first detected at wk14 or wk20. 

From this example, one can see that the two plots paint different but complementary pictures. With the regular circos plot, clones are treated as equal so the information on fractional contribution is lost. However, the number of detected clones is indicated by the length of each region around the perimeter of the circos. This information can be useful for some studies and it is lost in the weighted heat map since all compartments poportion adds to 100%. We recommend using the regular and circos plot in combination to obtain maximal information from any given dataset.

